## ✔️ 키워드 정리

### HTTP(Hypertext Transfer Protocol)

HTTP는 HTML과 같은 하이퍼미디어 문서를 전송하기 위한 애플리케이션 계층 프로토콜이다.<br/>
요청과 응답으로 구성되어 있으며, 일반적으로 80번 포트를 사용한다.


### HTTP와 HTTPS의 차이(TLS)

HTTP는 SSL/TLS 통신 방식을 사용하여 데이터를 암호화한다. <br/>
두 프로토콜 간 사용하는 포트 번호가 다르며, HTTPS는 SSL 인증서를 통한 신뢰성이 보장된다. <br/>
HTTPS는 암호화된 프로토콜을 사용하여 데이터가 전송중에 유출되거나 변조되는 것을 방지한다.

HTTPS는 비대칭키 암호화를 사용하여 안전하게 키를 교환하고, 대칭키 암호화를 사용하여 데이터를 빠르고 효율적으로 암호환다.

### 클라이언트-서버 모델

클라이언트 서버 모델은 서비스 요청자인 클라이언트와 서비스 자원의 제공자인 서버 간의 작업을 분리해주는 분산 애플리케이션 구조이자, 네트워크 아키텍처를 나타낸다. <br/>
클라이언트는/서버는 프로그램이 다른 프로그램에 요청을 전송하고 응답을 기다리는 상호 작용의 모델이다.

### stateless와 stateful

무상태 프로토콜
Stateless(상태 유지 안됨)

- 서버가 클라이언트의 상태를 보존하지 않음
- 장점: 서버 확장성 높음(스케일 아웃)
- 단점: 클라이언트가 추가 데이터 전송

Stateful(상태 유지)

**Stateful vs Stateless**

- 무상태는 응답 서버를 쉽게 바꿀 수 있다. → 무한한 서버 증설 가능

Stateless 실무 한계

---

- 모든 것을 무상태로 설계 할 수 있는 경우도 있고 없는 경우도 있다.
- 무상태
    - 예) 로그인이 필요 없는 단순한 서비스 소개 화면
- 상태 유지
    - 예) 로그인
- 로그인한 사용자의 경우 로그인 했다는 상태를 서버에 유지
- 일반적으로 브라우저 쿠키와 서버 세션 등을 사용해서 상태 유지
- 상태 유지는 최소한만 사용

### HTTP Cookie와 HTTP Session

기본적으로 HTTP 프로토콜 환경은 "connectionless, stateless"한 특성을 가지기 때문에 서버는 클라이언트가 누구인지 매번 확인해야한다.<br/>
이 특성을 보완하기 위해서 쿠키와 세션을 사용하게 된다.

쿠키란?<br/>

쿠키는 클라이언트(브라우저) 로컬에 저장되는 키와 값이 들어있는 작은 데이터 파일<br/>
사용자 인증이 유효한 시간을 명시할 수 있으며, 유효 시간이 정해지면 브라우저가 종료되어도 인증이 유지된다는 특징이 있음<br/>
쿠키는 클라이언트의 상태 정보를 로컬에 저장했다가 참조<br/>
클라이언트에 300개까지 쿠키저장 가능, 하나의 도메인당 20개의 값만 가질 수 있고, 하나의 쿠키값은 4KB까지 저장
Response Header에 Set-Cookie 속성을 사용하면 클라이언트에 쿠키를 만들 수 있음<br/>

쿠키는 사용자가 따로 요청하지 않아도 브라우저가 Request시에 Request Header를 넣어서 자동으로 서버에 전송합니다.

세션이란?

세션은 쿠키를 기반하고 있지만, 사용자 정보 파일을 브라우저에 저장하는 쿠키와 달리 세션은 서버 측에서 관리<br/>
서버에서는 클라이언트를 구분하기 위해 세션 ID를 부여하며 웹 브라우저가 서버에 접속해서 브라우저를 종료할 때까지 인증상태를 유지<br/>
물론 접속 시간에 제한을 두어 일정 시간 응답이 없다면 정보가 유지되지 않게 설정이 가능 합니다.
사용자에 대한 정보를 서버에 두기 때문에 쿠키보다 보안에 좋지만, 사용자가 많아질수록 서버 메모리를 많이 차지하게 됨<br/>
즉 동접자 수가 많은 웹 사이트인 경우 서버에 과부하를 주게 되므로 성능 저하의 요인이 됨<br/>
클라이언트가 Request를 보내면, 해당 서버의 엔진이 클라이언트에게 유일한 ID를 부여하는 데 이것이 바로 세션 ID

### HTTP 메시지 구조

HTTP 메시지에 모든 것을 전송

**H**yper**T**ext **T**ransfer **P**rotocol

- HTML, TEXT
- IMAGE, 음성, 영상, 파일
- JSON, XML(API)
- 거의 모든 형태의 데이터 전송 가능
- 서버간에 데이터를 주고 받을 때도 대부분 HTTP 사용

Start line → 요청과 응답의 형태가 다름.
Headers
공백 라인(CRLF)
Body
- 크기를 알기 어렵다. Headers의 Content-Length 항목 등을 활용한다.
- 위와 다르게 꼭 사람이 읽을 수 있는 텍스트 형태일 필요는 없다. 바이너리 등 가능
- 하나가 아니라 여럿일 수도 있다. 파일 업로드 등을 위해 쓰이는 multipart/form-data가 대표적

### HTTP 요청(Reuqest)와 응답(Response)

요청 메시지
- 종류: GET, POST, PUT, DELETE …
- 서버가 수행해야 할 동작 지정
    - GET: 리소스 조회
    - POST: 요청 내역 처리

응답 메시지
- start-line = request-line / status-line
- status-line = HTTP-version SP status-code SP reason-phrase CRLF
- HTTP 버전
- HTTP 상태 코드: 요청 성공, 실패를 나타냄
    - 200: 성공
    - 400: 클라이언트 요청 오류
    - 500: 서버 내부 오류
- 이유 문구: 사람이 이해할 수 있는 짧은 상태 코드 설명 글

### multipart/form-data

form은 입력 양식 전체를 감싸는 태그이다.
http Request의 Body 부분에 클라이언트가 전송하고자 하는 데이터를 넣을 수 있다.
Header의 Content-type에서 multipart/form-data로 지정을 하면 이미지나 파일을 서버로 전송할 수 있다.
✨ 메서드는 꼭 Post여야한다!

### HTTP 요청 메서드(HTTP request methods)

- GET → Read
- HEAD → GET without body
- POST → Submit (멱등성X) ⇒ Collection Pattern에서 Create로 사용
- PUT → Update (+Create) ⇒ Overwrite의 느낌
- PATCH → Update (partial: 부분적으로 업데이트 가능) (멱등성X)
- DELETE → Delete
- OPTIONS → 지원 확인

### 멱등성

동일한 요청을 한 번 보내는 것과 여러 번 연속으로 보내는 것이 같은 효과를 지니고, 서버의 상태도 동일하게 남을 때, 해당 HTTP 메서드가 멱등성을 가졌다고 말한다.

멱등성을 따질 땐 실제 서버의 백엔드 상태만 보면 되며, 각 요청하는 반환하는 응답 코드는 다를 수 있다.


### HTTP 응답 상태 코드(HTTP response status code)

클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능

- 1xx(Informational): 요청이 수신되어 처리중 → 거의 사용 안됨
- 2xx(Successful): 요청 정상 처리
- 3xx(Redirection): 요청을 완료하려면 추가 행동이 필요
- 4xx(Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
- 5xx(Server Erorr): 서버 오류, 서버가 정상 요청을 처리하지 못함

만약 모르는 상태 코드가 나타나면?

- 클라이언트가 인식할 수 없는 상태코드를 서버가 반환하면?
- 클라이언트는 상위 상태코드로 해석해서 처리
- 미래에 새로운 상태 코드가 추가되어도 클라이언트를 변경하지 않아도 됨
- 예)
    - 299 ??? → 2xx (Successful)
    - 451 ??? → 4xx ()


### 리다이렉션

URL 리다이렉션 혹은 URL 포워딩은 페이지 단위의 실제 리소스, 폼 혹은 전체 웹 애플리케이션이 다른 URL에 위치하고 있는 상태에서 링크를 존속시키는 기술이다.
HTTP는 많은 목표를 위해 사용되는 이런 동작을 수행하기 위해 특별한 종류의 응답인 HTTP 리다이렉트를 제공한다.


HTTP 응답 상태 코드 300번대에서 주로 이루어진다.

HTTP 리다이렉트 이외에도 리다이렉션을 정의하는 2가지의 방법이 있다.
1. ```<meta>``` 엘리먼트를 사용하는 HTML 리다이렉션<br/>
    HTTP 리다이렉트는 리다이렉션을 만드는 가장 좋은 방법이지만, 때때로 웹 개발자는 서버에 대한 제어권을 가지고 있지 않거나 그것을 구성할 수 없는 경우가 있다. 이런 특수한 상황들 때문에, 웹 개발자들은 refresh를 설정하기 위해 페이지의 <head> 내에 <meta> 엘리먼트와 http-equiv 속성으로 HTML 페이지를 만들 수 있다
2. DOM을 사용하는 Javascript 리다이렉션<br/>
    JavaScript 내에서의 리다이렉션은 window.location 프로퍼티에 값을 설정해서 만들어지며 새로운 페이지가 로드된다.

리다이렉션의 우선 순위는 다음과 같다.
1. 페이지가 읽힌 적도 없고 전송된 적도 없는 경우, HTTP 리다이렉트가 항상 먼저 실행된다.
2. 어떤 HTTP 리다이렉트로 없는 경우에, HTML 리다이렉트 (<meta>)가 실행된다.
3. JavaScript 리다이렉트는 최후의 수단으로써 사용되며, 클라이언트 측에서 JavaScript를 활성화시킨 경우에만 사용할 수 있다.